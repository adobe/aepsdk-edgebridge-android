/*
  Copyright 2022 Adobe. All rights reserved.
  This file is licensed to you under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License. You may obtain a copy
  of the License at http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software distributed under
  the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
  OF ANY KIND, either express or implied. See the License for the specific language
  governing permissions and limitations under the License.
*/

package com.adobe.marketing.mobile.edge.bridge;

import static com.adobe.marketing.mobile.edge.bridge.EdgeBridgeConstants.LOG_TAG;
import static com.adobe.marketing.mobile.util.MapUtils.isNullOrEmpty;

import androidx.annotation.NonNull;
import com.adobe.marketing.mobile.Event;
import com.adobe.marketing.mobile.EventSource;
import com.adobe.marketing.mobile.EventType;
import com.adobe.marketing.mobile.Extension;
import com.adobe.marketing.mobile.ExtensionApi;
import com.adobe.marketing.mobile.services.Log;
import com.adobe.marketing.mobile.util.CloneFailedException;
import com.adobe.marketing.mobile.util.DataReader;
import com.adobe.marketing.mobile.util.EventDataUtils;
import com.adobe.marketing.mobile.util.StringUtils;
import com.adobe.marketing.mobile.util.TimeUtils;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

class EdgeBridgeExtension extends Extension {

	private static final String LOG_SOURCE = "EdgeBridgeExtension";

	protected EdgeBridgeExtension(final ExtensionApi extensionApi) {
		super(extensionApi);
	}

	@NonNull
	@Override
	protected String getName() {
		return EdgeBridgeConstants.EXTENSION_NAME;
	}

	@NonNull
	@Override
	protected String getFriendlyName() {
		return EdgeBridgeConstants.FRIENDLY_NAME;
	}

	@NonNull
	@Override
	protected String getVersion() {
		return EdgeBridgeConstants.EXTENSION_VERSION;
	}

	@Override
	protected void onRegistered() {
		getApi().registerEventListener(EventType.GENERIC_TRACK, EventSource.REQUEST_CONTENT, this::handleTrackRequest);
		getApi()
			.registerEventListener(
				EventType.RULES_ENGINE,
				EventSource.RESPONSE_CONTENT,
				this::handleRulesEngineResponse
			);
	}

	/**
	 * Handles generic Analytics track events coming from the public APIs.
	 * @param event the generic track request event
	 */
	void handleTrackRequest(@NonNull final Event event) {
		final Map<String, Object> eventData = event.getEventData();

		if (isNullOrEmpty(eventData)) {
			Log.trace(
				LOG_TAG,
				LOG_SOURCE,
				"Unable to handle track request event with id '%s': event data is missing or empty.",
				event.getUniqueIdentifier()
			);
			return;
		}

		dispatchTrackRequest(eventData, event);
	}

	/**
	 * Handles Analytics track events generated by a rule consequence.
	 * @param event the rules engine response event
	 */
	void handleRulesEngineResponse(@NonNull final Event event) {
		final Map<String, Object> eventData = event.getEventData();

		if (isNullOrEmpty(eventData)) {
			Log.trace(
				LOG_TAG,
				LOG_SOURCE,
				"Ignoring Rules Engine response event with id '%s': event data is missing or empty.",
				event.getUniqueIdentifier()
			);
			return;
		}

		final Map<String, Object> consequence = DataReader.optTypedMap(
			Object.class,
			eventData,
			"triggeredconsequence",
			null
		);

		if (isNullOrEmpty(consequence)) {
			Log.trace(
				LOG_TAG,
				LOG_SOURCE,
				"Ignoring Rule Engine response event with id '%s': consequence data is invalid or empty.",
				event.getUniqueIdentifier()
			);
			return;
		}

		final String type = DataReader.optString(consequence, "type", null);

		if (!"an".equals(type)) {
			// Not an Analytics rules consequence
			return;
		}

		final String id = DataReader.optString(consequence, "id", null);

		if (StringUtils.isNullOrEmpty(id)) {
			Log.trace(
				LOG_TAG,
				LOG_SOURCE,
				"Ignoring Rule Engine response event with id '%s': consequence id is invalid or empty.",
				event.getUniqueIdentifier()
			);
			return;
		}

		final Map<String, Object> detail = DataReader.optTypedMap(Object.class, consequence, "detail", null);

		if (isNullOrEmpty(detail)) {
			Log.trace(
				LOG_TAG,
				LOG_SOURCE,
				"Ignoring Rule Engine response event with id '%s': consequence detail is invalid or empty.",
				event.getUniqueIdentifier()
			);
			return;
		}

		dispatchTrackRequest(detail, event);
	}

	/**
	 * Helper to create and dispatch an experience event.
	 * @param data map containing free-form data to send to Edge Network
	 * @param parentEvent the triggering parent event used for event chaining; its timestamp is set as xdm.timestamp
	 */
	private void dispatchTrackRequest(final Map<String, Object> data, final Event parentEvent) {
		Map<String, Object> xdmData = new HashMap<>();
		xdmData.put("eventType", EdgeBridgeConstants.JsonValues.EVENT_TYPE);
		xdmData.put("timestamp", TimeUtils.getISO8601UTCDateWithMilliseconds(new Date(parentEvent.getTimestamp())));

		Map<String, Object> eventData = new HashMap<>();
		eventData.put("xdm", xdmData);
		eventData.put("data", formatData(data));

		final Event event = new Event.Builder(
			EdgeBridgeConstants.EventNames.EDGE_BRIDGE_REQUEST,
			EventType.EDGE,
			EventSource.REQUEST_CONTENT
		)
			.chainToParentEvent(parentEvent)
			.setEventData(eventData)
			.build();

		getApi().dispatch(event);
	}

	/**
	 * Formats track event data to the required Analytics Edge translator format under the `data.__adobe.analytics` object.
	 *
	 * The following is the mapping logic:
	 * - The "action" field is mapped to "data.__adobe.analytics.linkName", and "data.__adobe.analytics.linkType" is set to "other".
	 * - The "state" field is mapped to "data.__adobe.analytics.pageName".
	 * - Any "contextData" keys that start with the "&&" prefix are mapped to "data.__adobe.analytics" with the prefix removed.
	 * - Any "contextData" keys without the "&&" prefix are mapped to "data.__adobe.analytics.contextData".
	 * - Any additional fields are passed through and left directly under the "data" object.
	 *
	 * As an example, the following track event data:
	 * ```
	 * {
	 *    "action": "action name",
	 *    "contextData": {
	 *       "&&c1": "propValue1",
	 *       "key1": "value1"
	 *    },
	 *    "key2": "value2"
	 * }
	 * ```
	 * Is mapped to:
	 * ```
	 * {
	 *   "data": {
	 *     "__adobe": {
	 *       "analytics": {
	 *         "linkName": "action name",
	 *         "linkType": "other",
	 *         "c1": "propValue1",
	 *         "contextData": {
	 *           "key1": "value1"
	 *         }
	 *       }
	 *     },
	 *     "key2": "value2"
	 *   }
	 * }
	 * ```
	 *
	 * @param data track event data
	 * @return data formatted for the Analytics Edge translator.
	 */
	private Map<String, Object> formatData(final Map<String, Object> data) {
		// Create a mutable copy of data
		Map<String, Object> mutableData = deepCopy(data);
		// __adobe.analytics data container
		Map<String, Object> analyticsData = new HashMap<>();

		// Extract contextData
		final Map<String, Object> contextData = DataReader.optTypedMap(
			Object.class,
			mutableData,
			EdgeBridgeConstants.AnalyticsKeys.CONTEXT_DATA,
			null
		);
		mutableData.remove(EdgeBridgeConstants.AnalyticsKeys.CONTEXT_DATA);
		if (!isNullOrEmpty(contextData)) {
			Map<String, Object> prefixedData = new HashMap<>();
			Map<String, Object> nonPrefixedData = new HashMap<>();

			for (Map.Entry<String, Object> entry : contextData.entrySet()) {
				String key = entry.getKey();
				Object value = entry.getValue();

				// Check if the key starts with the specified prefix and add to corresponding map
				if (key.startsWith(EdgeBridgeConstants.EdgeValues.PREFIX)) {
					String newKey = key.substring(EdgeBridgeConstants.EdgeValues.PREFIX.length());
					prefixedData.put(newKey, value);
				} else {
					nonPrefixedData.put(key, value);
				}
			}

			// If there are prefixed data entries, add them to analyticsData
			if (!prefixedData.isEmpty()) {
				analyticsData.putAll(prefixedData);
			}

			// If there are non-prefixed data entries, add them under the contextData key
			if (!nonPrefixedData.isEmpty()) {
				analyticsData.put(EdgeBridgeConstants.EdgeKeys.CONTEXT_DATA, nonPrefixedData);
			}
		}

		// Process action
		Object actionValue = mutableData.remove(EdgeBridgeConstants.AnalyticsKeys.ACTION);
		if (actionValue instanceof String) { // Validates non-null and correct type
			String action = (String) actionValue;
			analyticsData.put(EdgeBridgeConstants.EdgeKeys.LINK_NAME, action);
			analyticsData.put(EdgeBridgeConstants.EdgeKeys.LINK_TYPE, EdgeBridgeConstants.EdgeValues.OTHER);
		}

		// Process state
		Object stateValue = mutableData.remove(EdgeBridgeConstants.AnalyticsKeys.STATE);
		if (stateValue instanceof String) { // Validates non-null and correct type
			String state = (String) stateValue;
			analyticsData.put(EdgeBridgeConstants.EdgeKeys.PAGE_NAME, state);
		}

		// If analyticsData is not empty, add it to mutableData under __adobe.analytics
		if (!analyticsData.isEmpty()) {
			Map<String, Object> adobeAnalytics = new HashMap<>();
			adobeAnalytics.put(EdgeBridgeConstants.EdgeKeys.ANALYTICS, analyticsData);
			mutableData.put(EdgeBridgeConstants.EdgeKeys.ADOBE, adobeAnalytics);
		}

		return mutableData;
	}

	/**
	 * Creates a deep copy of the provided {@link Map}.
	 *
	 * @param map to be copied
	 * @return {@link Map} containing a deep copy of all the elements in {@code map}
	 */
	Map<String, Object> deepCopy(final Map<String, Object> map) {
		try {
			return EventDataUtils.clone(map);
		} catch (CloneFailedException e) {
			Log.warning(
				LOG_TAG,
				LOG_SOURCE,
				"Unable to deep copy map. CloneFailedException: %s",
				e.getLocalizedMessage()
			);
		}

		return null;
	}
}
